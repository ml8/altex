<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>altex — Accessible LaTeX</title>
<style>
  *, *::before, *::after { box-sizing: border-box; }
  body { font-family: system-ui, sans-serif; max-width: 640px; margin: 2rem auto; padding: 0 1rem; color: #1a1a1a; }
  h1 { font-size: 1.5rem; margin-bottom: .25rem; }
  h1 span { font-weight: normal; color: #666; font-size: 1rem; }
  form { background: #f7f7f7; border: 1px solid #ddd; border-radius: 8px; padding: 1.25rem; margin: 1.5rem 0; }
  label { display: block; font-weight: 600; margin-top: .75rem; font-size: .9rem; }
  label:first-child { margin-top: 0; }
  input[type="file"] { display: block; margin-top: .25rem; }
  .row { display: flex; gap: 1rem; align-items: end; margin-top: .75rem; }
  .row label { flex: 1; margin-top: 0; }
  select { width: 100%; padding: .3rem; border-radius: 4px; border: 1px solid #ccc; }
  .check { display: flex; align-items: center; gap: .4rem; font-weight: normal; }
  button { margin-top: 1rem; padding: .5rem 1.5rem; background: #0969da; color: #fff; border: none; border-radius: 6px; font-size: .95rem; cursor: pointer; }
  button:disabled { background: #999; cursor: wait; }
  #status { margin-top: 1rem; font-size: .9rem; color: #555; }
  #results { display: none; margin-top: 1.5rem; }
  #results h2 { font-size: 1.1rem; margin-bottom: .5rem; }
  table { width: 100%; border-collapse: collapse; font-size: .85rem; }
  th, td { text-align: left; padding: .35rem .5rem; border-bottom: 1px solid #ddd; }
  th { background: #f0f0f0; }
  .dl { display: inline-block; margin-top: .75rem; padding: .45rem 1.2rem; background: #1a7f37; color: #fff; border-radius: 6px; text-decoration: none; font-size: .9rem; }
  .dl:hover { background: #15652c; }
  .error { color: #cf222e; font-weight: 600; }
  .meta td:first-child { font-weight: 600; width: 45%; }
  .validation { background: #f0f8f0; border: 1px solid #c6e6c6; border-radius: 8px; padding: 1rem; margin-top: 1rem; }
  .validation.warn { background: #fff8e1; border-color: #e6d9a0; }
  .validation h3 { font-size: .95rem; margin: 0 0 .5rem 0; }
  .validation .stat { font-size: 2rem; font-weight: 700; margin: .25rem 0; }
  .validation .stat.good { color: #1a7f37; }
  .validation .stat.warn { color: #9a6700; }
  .validation .detail { font-size: .8rem; color: #555; margin-top: .25rem; }
  .val-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem; }
  .rule-list { font-size: .8rem; margin-top: .5rem; }
  .rule-list li { margin-bottom: .25rem; }
  .rule-fixed { color: #1a7f37; }
  .rule-remaining { color: #9a6700; }
  .info-section { margin-top: 3rem; border-top: 1px solid #ddd; padding-top: 1.5rem; color: #444; font-size: 0.9rem; }
  .info-section h2 { font-size: 1.2rem; color: #1a1a1a; }
  .info-section h3 { font-size: 1rem; margin-top: 1rem; }
  .info-section ul { padding-left: 1.2rem; }
  .info-section li { margin-bottom: 0.25rem; }
</style>
</head>
<body>

<h1>altex <span>Accessible LaTeX</span></h1>
<p>Upload your LaTeX source and compiled PDF to embed accessibility tags and alt-text.</p>

<form id="form">
  <label>LaTeX source (.tex)
    <input type="file" id="tex" accept=".tex" required>
  </label>
  <label>Compiled PDF (.pdf)
    <input type="file" id="pdf" accept=".pdf" required>
  </label>
  <div class="row">
    <label>Language
      <select id="lang">
        <option value="en" selected>English</option>
        <option value="es">Spanish</option>
        <option value="fr">French</option>
        <option value="de">German</option>
      </select>
    </label>
    <label class="check">
      <input type="checkbox" id="fix_enc" checked> Fix font encoding (Ghostscript)
    </label>
  </div>
  <div class="row">
    <label>Math-to-speech
      <select id="math_speech">
        <option value="none" selected>None (raw LaTeX)</option>
        <option value="sre">SRE (latex2mathml + Speech Rule Engine)</option>
        <option value="mathjax">MathJax (mathjax-full + SRE)</option>
      </select>
    </label>
    <label class="check">
      <input type="checkbox" id="embed_alt"> Embed HTML alternative
    </label>
  </div>
  <button type="submit" id="btn">Tag PDF</button>
</form>
<div id="status"></div>

<div id="results">
  <h2>PDF/UA Validation</h2>
  <div id="validation-section"></div>
  <h2 style="margin-top:1rem">Accessibility Summary</h2>
  <table class="meta">
    <tbody id="meta-body"></tbody>
  </table>
  <h2 style="margin-top:1rem">Structure Elements</h2>
  <table>
    <thead><tr><th>Tag</th><th>Count</th></tr></thead>
    <tbody id="elem-body"></tbody>
  </table>
  <a id="dl-link" class="dl" href="#">⬇ Download Tagged PDF</a>
</div>

<div class="info-section">
  <h2>About this tool</h2>
  <p>
    <strong>altex</strong> is a proof-of-concept utility that enhances PDF accessibility by
    post-processing files generated from LaTeX. It uses the semantic structure from your
    source <code>.tex</code> file to tag the compiled PDF.
  </p>
  
  <h3>How it works</h3>
  <ul>
    <li><strong>Parses LaTeX:</strong> Extracts document structure (headings, lists, math, figures) from your source code.</li>
    <li><strong>Tags PDF:</strong> Maps this structure to the PDF content, adding PDF/UA accessibility tags.</li>
    <li><strong>Fixes Metadata:</strong> Sets required metadata like title, language, and tab order.</li>
    <li><strong>Validates:</strong> Checks the result against PDF/UA-1 standards using verapdf.</li>
  </ul>

  <p>
    <em>Note:</em> This is an automated tool. While it significantly improves accessibility compliance,
    complex documents may still require manual verification.
  </p>
  
  <p>
    <a href="https://github.com/ml8/accessible-latex" target="_blank">View source on GitHub</a>
  </p>
</div>

<script>
const form = document.getElementById('form');
const btn = document.getElementById('btn');
const status = document.getElementById('status');
const results = document.getElementById('results');

form.addEventListener('submit', async (e) => {
  e.preventDefault();
  const tex = document.getElementById('tex').files[0];
  const pdf = document.getElementById('pdf').files[0];
  if (!tex || !pdf) return;

  btn.disabled = true;
  status.textContent = 'Processing…';
  status.className = '';
  results.style.display = 'none';

  const fd = new FormData();
  fd.append('tex', tex);
  fd.append('pdf', pdf);
  fd.append('lang', document.getElementById('lang').value);
  fd.append('fix_encoding', document.getElementById('fix_enc').checked ? 'true' : 'false');
  fd.append('math_speech', document.getElementById('math_speech').value);
  fd.append('embed_alt', document.getElementById('embed_alt').checked ? 'true' : 'false');

  try {
    const res = await fetch('/api/tag', { method: 'POST', body: fd });
    const data = await res.json();
    if (!res.ok) throw new Error(data.error || 'Server error');

    // Validation comparison (before → after).
    const vs = document.getElementById('validation-section');
    vs.innerHTML = '';
    if (data.validation_before || data.validation_after) {
      const before = data.validation_before;
      const after = data.validation_after;
      let html = '<div class="val-grid">';

      // Before card.
      if (before) {
        html += `<div class="validation warn">
          <h3>Before (original PDF)</h3>
          <div class="stat warn">${before.failed_checks} failures</div>
          <div class="detail">${before.failed_rules} rules failed / ${before.passed_rules + before.failed_rules} checked</div>
        </div>`;
      }
      // After card.
      if (after) {
        const cls = after.failed_checks === 0 ? 'good' : 'warn';
        const bg = after.failed_checks === 0 ? 'validation' : 'validation warn';
        html += `<div class="${bg}">
          <h3>After (tagged PDF)</h3>
          <div class="stat ${cls}">${after.failed_checks} failures</div>
          <div class="detail">${after.failed_rules} rules failed / ${after.passed_rules + after.failed_rules} checked</div>
        </div>`;
      }
      html += '</div>';

      // Rules fixed.
      if (before && after) {
        const beforeClauses = new Set((before.details || []).map(d => d.clause));
        const afterClauses = new Set((after.details || []).map(d => d.clause));
        const fixed = [...beforeClauses].filter(c => !afterClauses.has(c));
        const remaining = (after.details || []);

        if (fixed.length > 0 || remaining.length > 0) {
          html += '<div style="margin-top:.75rem">';
          if (fixed.length > 0) {
            html += '<ul class="rule-list">';
            const beforeMap = Object.fromEntries((before.details || []).map(d => [d.clause, d]));
            for (const c of fixed) {
              const desc = beforeMap[c]?.description || c;
              html += `<li class="rule-fixed">✅ Fixed [${c}]: ${desc.slice(0, 80)}</li>`;
            }
            html += '</ul>';
          }
          if (remaining.length > 0) {
            html += '<ul class="rule-list">';
            for (const r of remaining) {
              html += `<li class="rule-remaining">⚠ [${r.clause}] ×${r.count}: ${r.description.slice(0, 70)}</li>`;
            }
            html += '</ul>';
          }
          html += '</div>';
        }
      }
      vs.innerHTML = html;
    } else {
      vs.innerHTML = '<p class="detail">verapdf not available — install from <a href="https://verapdf.org/software/">verapdf.org</a> for PDF/UA validation.</p>';
    }

    // Metadata table.
    const mb = document.getElementById('meta-body');
    mb.innerHTML = '';
    const meta = [
      ['Title', data.title],
      ['Language', data.lang],
      ['Pages', data.pages],
      ['Elements with alt-text', data.alt_count],
      ['BDC markers (page 1)', data.bdc_markers_page1],
      ['Marked as tagged', data.marked ? '✅ Yes' : '❌ No'],
      ['Alt document embedded', data.alt_document ? '✅ Yes' : '—'],
    ];
    for (const [k, v] of meta) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${k}</td><td>${v}</td>`;
      mb.appendChild(tr);
    }

    // Elements table.
    const eb = document.getElementById('elem-body');
    eb.innerHTML = '';
    for (const [tag, count] of Object.entries(data.elements).sort()) {
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${tag}</td><td>${count}</td>`;
      eb.appendChild(tr);
    }

    // Download link — handle both storage modes.
    const dlLink = document.getElementById('dl-link');
    if (data.pdf_base64) {
      // Inline mode: decode base64 to blob URL.
      const binary = atob(data.pdf_base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      const blob = new Blob([bytes], { type: 'application/pdf' });
      dlLink.href = URL.createObjectURL(blob);
      dlLink.download = 'tagged.pdf';
    } else if (data.download_url) {
      // Local mode: use server download URL.
      dlLink.href = data.download_url;
    }
    results.style.display = 'block';
    status.textContent = 'Done.';
  } catch (err) {
    status.textContent = err.message;
    status.className = 'error';
  } finally {
    btn.disabled = false;
  }
});
</script>
</body>
</html>
